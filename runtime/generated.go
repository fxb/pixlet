package runtime

// Code generated by runtime/gen. DO NOT EDIT.

import (
	"fmt"
	"math"
	"sync"

	"github.com/mitchellh/hashstructure/v2"
	"go.starlark.net/starlark"
	"go.starlark.net/starlarkstruct"
	"tidbyt.dev/pixlet/render"
	"tidbyt.dev/pixlet/render/animation"
)

var (
	once   sync.Once
	module starlark.StringDict
)

func LoadModule() (starlark.StringDict, error) {
	once.Do(func() {
		fnt := starlark.NewDict(len(render.Font))
		for k, _ := range render.Font {
			fnt.SetKey(starlark.String(k), starlark.String(k))
		}
		fnt.Freeze()

		module = starlark.StringDict{
			"render": &starlarkstruct.Module{
				Name: "render",
				Members: starlark.StringDict{
					"Root":  starlark.NewBuiltin("Root", newRoot),
					"Plot":  starlark.NewBuiltin("Plot", newPlot),
					"fonts": fnt,

					"Animate": starlark.NewBuiltin("Animate", newAnimate),

					"AnimatedPositioned": starlark.NewBuiltin("AnimatedPositioned", newAnimatedPositioned),

					"Animation": starlark.NewBuiltin("Animation", newAnimation),

					"Bounce": starlark.NewBuiltin("Bounce", newBounce),

					"Box": starlark.NewBuiltin("Box", newBox),

					"Circle": starlark.NewBuiltin("Circle", newCircle),

					"Column": starlark.NewBuiltin("Column", newColumn),

					"Image": starlark.NewBuiltin("Image", newImage),

					"Keyframe": starlark.NewBuiltin("Keyframe", newKeyframe),

					"Marquee": starlark.NewBuiltin("Marquee", newMarquee),

					"Origin": starlark.NewBuiltin("Origin", newOrigin),

					"Padding": starlark.NewBuiltin("Padding", newPadding),

					"Rotate": starlark.NewBuiltin("Rotate", newRotate),

					"Row": starlark.NewBuiltin("Row", newRow),

					"Scale": starlark.NewBuiltin("Scale", newScale),

					"Stack": starlark.NewBuiltin("Stack", newStack),

					"Text": starlark.NewBuiltin("Text", newText),

					"Translate": starlark.NewBuiltin("Translate", newTranslate),

					"WrappedText": starlark.NewBuiltin("WrappedText", newWrappedText),
				},
			},
		}
	})

	return module, nil
}

type Widget interface {
	AsRenderWidget() render.Widget
}
type Animate struct {
	Widget

	animation.Animate

	starlarkChild starlark.Value

	starlarkKeyframes *starlark.List

	starlarkOrigin starlark.Value

	starlarkCurve starlark.Value

	starlarkRounding starlark.String
}

func newAnimate(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		child     starlark.Value
		keyframes *starlark.List
		duration  starlark.Int
		delay     starlark.Int
		origin    starlark.Value
		curve     starlark.Value
		rounding  starlark.String
	)

	if err := starlark.UnpackArgs(
		"Animate",
		args, kwargs,
		"child", &child,
		"keyframes", &keyframes,
		"duration", &duration,
		"delay?", &delay,
		"origin?", &origin,
		"curve?", &curve,
		"rounding?", &rounding,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Animate: %s", err)
	}

	w := &Animate{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.starlarkKeyframes = keyframes
	for i := 0; i < keyframes.Len(); i++ {
		if keyframesVal, ok := keyframes.Index(i).(*Keyframe); ok {
			w.Keyframes = append(w.Keyframes, keyframesVal.Keyframe)
		} else {
			return nil, fmt.Errorf("invalid type for keyframes: %s (expected Keyframe)", keyframesVal.Type())
		}
	}

	w.Duration = int(duration.BigInt().Int64())

	w.Delay = int(delay.BigInt().Int64())

	w.starlarkOrigin = origin
	if origin == nil {
		w.Origin = animation.DefaultOrigin
	} else if originVal, ok := origin.(*Origin); ok {
		w.Origin = originVal.Origin
	} else {
		return nil, fmt.Errorf("invalid type for origin: %s (expected Origin)", origin.Type())
	}

	w.starlarkCurve = curve
	if curve == nil {
		w.Curve = animation.DefaultCurve
	} else if curveVal, err := CurveFromStarlark(curve); err == nil {
		w.Curve = curveVal
	} else {
		return nil, err
	}

	w.starlarkRounding = rounding
	switch rounding {
	case "round":
		w.Rounding = animation.Round{}
	case "floor":
		w.Rounding = animation.RoundFloor{}
	case "ceil":
		w.Rounding = animation.RoundCeil{}
	case "none":
		w.Rounding = animation.RoundNone{}
	case "":
		w.Rounding = animation.DefaultRounding
	default:
		return nil, fmt.Errorf("invalid type for rounding: %s (expected 'round', 'floor', 'ceil' or 'none')", rounding.Type())
	}

	return w, nil
}

func (w *Animate) AsRenderWidget() render.Widget {
	return &w.Animate
}

func (w *Animate) AttrNames() []string {
	return []string{
		"child", "keyframes", "duration", "delay", "origin", "curve", "rounding",
	}
}

func (w *Animate) Attr(name string) (starlark.Value, error) {
	switch name {

	case "child":

		return w.starlarkChild, nil

	case "keyframes":

		return w.starlarkKeyframes, nil

	case "duration":

		return starlark.MakeInt(w.Duration), nil

	case "delay":

		return starlark.MakeInt(w.Delay), nil

	case "origin":

		return w.starlarkOrigin, nil

	case "curve":

		return w.starlarkCurve, nil

	case "rounding":

		return w.starlarkRounding, nil

	default:
		return nil, nil
	}
}

func (w *Animate) String() string       { return "Animate(...)" }
func (w *Animate) Type() string         { return "Animate" }
func (w *Animate) Freeze()              {}
func (w *Animate) Truth() starlark.Bool { return true }

func (w *Animate) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type AnimatedPositioned struct {
	Widget

	animation.AnimatedPositioned

	starlarkChild starlark.Value

	starlarkCurve starlark.Value
}

func newAnimatedPositioned(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		child    starlark.Value
		xstart   starlark.Int
		xend     starlark.Int
		ystart   starlark.Int
		yend     starlark.Int
		duration starlark.Int
		curve    starlark.Value
		delay    starlark.Int
		hold     starlark.Int
	)

	if err := starlark.UnpackArgs(
		"AnimatedPositioned",
		args, kwargs,
		"child?", &child,
		"xstart?", &xstart,
		"xend?", &xend,
		"ystart?", &ystart,
		"yend?", &yend,
		"duration?", &duration,
		"curve?", &curve,
		"delay?", &delay,
		"hold?", &hold,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for AnimatedPositioned: %s", err)
	}

	w := &AnimatedPositioned{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.XStart = int(xstart.BigInt().Int64())

	w.XEnd = int(xend.BigInt().Int64())

	w.YStart = int(ystart.BigInt().Int64())

	w.YEnd = int(yend.BigInt().Int64())

	w.Duration = int(duration.BigInt().Int64())

	w.starlarkCurve = curve
	if curve == nil {
		w.Curve = animation.DefaultCurve
	} else if curveVal, err := CurveFromStarlark(curve); err == nil {
		w.Curve = curveVal
	} else {
		return nil, err
	}

	w.Delay = int(delay.BigInt().Int64())

	w.Hold = int(hold.BigInt().Int64())

	return w, nil
}

func (w *AnimatedPositioned) AsRenderWidget() render.Widget {
	return &w.AnimatedPositioned
}

func (w *AnimatedPositioned) AttrNames() []string {
	return []string{
		"child", "xstart", "xend", "ystart", "yend", "duration", "curve", "delay", "hold",
	}
}

func (w *AnimatedPositioned) Attr(name string) (starlark.Value, error) {
	switch name {

	case "child":

		return w.starlarkChild, nil

	case "xstart":

		return starlark.MakeInt(w.XStart), nil

	case "xend":

		return starlark.MakeInt(w.XEnd), nil

	case "ystart":

		return starlark.MakeInt(w.YStart), nil

	case "yend":

		return starlark.MakeInt(w.YEnd), nil

	case "duration":

		return starlark.MakeInt(w.Duration), nil

	case "curve":

		return w.starlarkCurve, nil

	case "delay":

		return starlark.MakeInt(w.Delay), nil

	case "hold":

		return starlark.MakeInt(w.Hold), nil

	default:
		return nil, nil
	}
}

func (w *AnimatedPositioned) String() string       { return "AnimatedPositioned(...)" }
func (w *AnimatedPositioned) Type() string         { return "AnimatedPositioned" }
func (w *AnimatedPositioned) Freeze()              {}
func (w *AnimatedPositioned) Truth() starlark.Bool { return true }

func (w *AnimatedPositioned) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Animation struct {
	Widget

	render.Animation

	starlarkChildren *starlark.List
}

func newAnimation(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		children *starlark.List
	)

	if err := starlark.UnpackArgs(
		"Animation",
		args, kwargs,
		"children?", &children,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Animation: %s", err)
	}

	w := &Animation{}

	var childrenVal starlark.Value
	childrenIter := children.Iterate()
	defer childrenIter.Done()
	for i := 0; childrenIter.Next(&childrenVal); {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(),
				i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	return w, nil
}

func (w *Animation) AsRenderWidget() render.Widget {
	return &w.Animation
}

func (w *Animation) AttrNames() []string {
	return []string{
		"children",
	}
}

func (w *Animation) Attr(name string) (starlark.Value, error) {
	switch name {

	case "children":

		return w.starlarkChildren, nil

	default:
		return nil, nil
	}
}

func (w *Animation) String() string       { return "Animation(...)" }
func (w *Animation) Type() string         { return "Animation" }
func (w *Animation) Freeze()              {}
func (w *Animation) Truth() starlark.Bool { return true }

func (w *Animation) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Bounce struct {
	Widget

	animation.Bounce

	starlarkChild starlark.Value

	starlarkCurve starlark.Value
}

func newBounce(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		child            starlark.Value
		width            starlark.Int
		height           starlark.Int
		bounce_direction starlark.String
		bounce_always    starlark.Bool
		pause            starlark.Int
		curve            starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Bounce",
		args, kwargs,
		"child", &child,
		"width?", &width,
		"height?", &height,
		"bounce_direction?", &bounce_direction,
		"bounce_always?", &bounce_always,
		"pause?", &pause,
		"curve?", &curve,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Bounce: %s", err)
	}

	w := &Bounce{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.Width = int(width.BigInt().Int64())

	w.Height = int(height.BigInt().Int64())

	w.BounceDirection = bounce_direction.GoString()

	w.BounceAlways = bool(bounce_always)

	w.Pause = int(pause.BigInt().Int64())

	w.starlarkCurve = curve
	if curve == nil {
		w.Curve = animation.DefaultCurve
	} else if curveVal, err := CurveFromStarlark(curve); err == nil {
		w.Curve = curveVal
	} else {
		return nil, err
	}

	return w, nil
}

func (w *Bounce) AsRenderWidget() render.Widget {
	return &w.Bounce
}

func (w *Bounce) AttrNames() []string {
	return []string{
		"child", "width", "height", "bounce_direction", "bounce_always", "pause", "curve",
	}
}

func (w *Bounce) Attr(name string) (starlark.Value, error) {
	switch name {

	case "child":

		return w.starlarkChild, nil

	case "width":

		return starlark.MakeInt(w.Width), nil

	case "height":

		return starlark.MakeInt(w.Height), nil

	case "bounce_direction":

		return starlark.String(w.BounceDirection), nil

	case "bounce_always":

		return starlark.Bool(w.BounceAlways), nil

	case "pause":

		return starlark.MakeInt(w.Pause), nil

	case "curve":

		return w.starlarkCurve, nil

	default:
		return nil, nil
	}
}

func (w *Bounce) String() string       { return "Bounce(...)" }
func (w *Bounce) Type() string         { return "Bounce" }
func (w *Bounce) Freeze()              {}
func (w *Bounce) Truth() starlark.Bool { return true }

func (w *Bounce) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Box struct {
	Widget

	render.Box

	starlarkChild starlark.Value

	starlarkColor starlark.String
}

func newBox(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		child   starlark.Value
		width   starlark.Int
		height  starlark.Int
		padding starlark.Int
		color   starlark.String
	)

	if err := starlark.UnpackArgs(
		"Box",
		args, kwargs,
		"child?", &child,
		"width?", &width,
		"height?", &height,
		"padding?", &padding,
		"color?", &color,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Box: %s", err)
	}

	w := &Box{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.Width = int(width.BigInt().Int64())

	w.Height = int(height.BigInt().Int64())

	w.Padding = int(padding.BigInt().Int64())

	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	return w, nil
}

func (w *Box) AsRenderWidget() render.Widget {
	return &w.Box
}

func (w *Box) AttrNames() []string {
	return []string{
		"child", "width", "height", "padding", "color",
	}
}

func (w *Box) Attr(name string) (starlark.Value, error) {
	switch name {

	case "child":

		return w.starlarkChild, nil

	case "width":

		return starlark.MakeInt(w.Width), nil

	case "height":

		return starlark.MakeInt(w.Height), nil

	case "padding":

		return starlark.MakeInt(w.Padding), nil

	case "color":

		return w.starlarkColor, nil

	default:
		return nil, nil
	}
}

func (w *Box) String() string       { return "Box(...)" }
func (w *Box) Type() string         { return "Box" }
func (w *Box) Freeze()              {}
func (w *Box) Truth() starlark.Bool { return true }

func (w *Box) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Circle struct {
	Widget

	render.Circle

	starlarkColor starlark.String

	starlarkChild starlark.Value
}

func newCircle(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		color    starlark.String
		diameter starlark.Int
		child    starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Circle",
		args, kwargs,
		"color", &color,
		"diameter", &diameter,
		"child?", &child,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Circle: %s", err)
	}

	w := &Circle{}

	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.Diameter = int(diameter.BigInt().Int64())

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	return w, nil
}

func (w *Circle) AsRenderWidget() render.Widget {
	return &w.Circle
}

func (w *Circle) AttrNames() []string {
	return []string{
		"color", "diameter", "child",
	}
}

func (w *Circle) Attr(name string) (starlark.Value, error) {
	switch name {

	case "color":

		return w.starlarkColor, nil

	case "diameter":

		return starlark.MakeInt(w.Diameter), nil

	case "child":

		return w.starlarkChild, nil

	default:
		return nil, nil
	}
}

func (w *Circle) String() string       { return "Circle(...)" }
func (w *Circle) Type() string         { return "Circle" }
func (w *Circle) Freeze()              {}
func (w *Circle) Truth() starlark.Bool { return true }

func (w *Circle) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Column struct {
	Widget

	render.Column

	starlarkChildren *starlark.List
}

func newColumn(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		children    *starlark.List
		main_align  starlark.String
		cross_align starlark.String
		expanded    starlark.Bool
	)

	if err := starlark.UnpackArgs(
		"Column",
		args, kwargs,
		"children", &children,
		"main_align?", &main_align,
		"cross_align?", &cross_align,
		"expanded?", &expanded,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Column: %s", err)
	}

	w := &Column{}

	var childrenVal starlark.Value
	childrenIter := children.Iterate()
	defer childrenIter.Done()
	for i := 0; childrenIter.Next(&childrenVal); {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(),
				i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	w.MainAlign = main_align.GoString()

	w.CrossAlign = cross_align.GoString()

	w.Expanded = bool(expanded)

	return w, nil
}

func (w *Column) AsRenderWidget() render.Widget {
	return &w.Column
}

func (w *Column) AttrNames() []string {
	return []string{
		"children", "main_align", "cross_align", "expanded",
	}
}

func (w *Column) Attr(name string) (starlark.Value, error) {
	switch name {

	case "children":

		return w.starlarkChildren, nil

	case "main_align":

		return starlark.String(w.MainAlign), nil

	case "cross_align":

		return starlark.String(w.CrossAlign), nil

	case "expanded":

		return starlark.Bool(w.Expanded), nil

	default:
		return nil, nil
	}
}

func (w *Column) String() string       { return "Column(...)" }
func (w *Column) Type() string         { return "Column" }
func (w *Column) Freeze()              {}
func (w *Column) Truth() starlark.Bool { return true }

func (w *Column) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Image struct {
	Widget

	render.Image

	size *starlark.Builtin
}

func newImage(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		src    starlark.String
		width  starlark.Int
		height starlark.Int
	)

	if err := starlark.UnpackArgs(
		"Image",
		args, kwargs,
		"src", &src,
		"width?", &width,
		"height?", &height,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Image: %s", err)
	}

	w := &Image{}

	w.Src = src.GoString()

	w.Width = int(width.BigInt().Int64())

	w.Height = int(height.BigInt().Int64())

	w.size = starlark.NewBuiltin("size", imageSize)

	if err := w.Init(); err != nil {
		return nil, err
	}

	return w, nil
}

func (w *Image) AsRenderWidget() render.Widget {
	return &w.Image
}

func (w *Image) AttrNames() []string {
	return []string{
		"src", "width", "height", "delay",
	}
}

func (w *Image) Attr(name string) (starlark.Value, error) {
	switch name {

	case "src":

		return starlark.String(w.Src), nil

	case "width":

		return starlark.MakeInt(w.Width), nil

	case "height":

		return starlark.MakeInt(w.Height), nil

	case "delay":

		return starlark.MakeInt(w.Delay), nil

	case "size":
		return w.size.BindReceiver(w), nil

	default:
		return nil, nil
	}
}

func (w *Image) String() string       { return "Image(...)" }
func (w *Image) Type() string         { return "Image" }
func (w *Image) Freeze()              {}
func (w *Image) Truth() starlark.Bool { return true }

func (w *Image) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func imageSize(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	w := b.Receiver().(*Image)
	width, height := w.Size()

	return starlark.Tuple([]starlark.Value{
		starlark.MakeInt(width),
		starlark.MakeInt(height),
	}), nil
}

type Keyframe struct {
	animation.Keyframe

	starlarkPercentage starlark.Value

	starlarkTransforms *starlark.List
}

func newKeyframe(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		percentage starlark.Value
		transforms *starlark.List
	)

	if err := starlark.UnpackArgs(
		"Keyframe",
		args, kwargs,
		"percentage", &percentage,
		"transforms", &transforms,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Keyframe: %s", err)
	}

	w := &Keyframe{}

	w.starlarkPercentage = percentage
	{

		if val, err := NumberOrPercentageFromStarlark(percentage, 0.0, 1.0, map[string]float64{"from": 0.0, "to": 1.0}); err == nil {

			w.Percentage = val
		} else {
			return nil, err
		}
	}

	w.starlarkTransforms = transforms
	for i := 0; i < transforms.Len(); i++ {
		switch transformsVal := transforms.Index(i).(type) {
		case *Translate:
			w.Transforms = append(w.Transforms, transformsVal.Translate)
		case *Scale:
			w.Transforms = append(w.Transforms, transformsVal.Scale)
		case *Rotate:
			w.Transforms = append(w.Transforms, transformsVal.Rotate)
		default:
			return nil, fmt.Errorf("expected transform, but got '%s'", transformsVal.Type())
		}
	}

	return w, nil
}

func (w *Keyframe) AttrNames() []string {
	return []string{
		"percentage", "transforms",
	}
}

func (w *Keyframe) Attr(name string) (starlark.Value, error) {
	switch name {

	case "percentage":

		return w.starlarkPercentage, nil

	case "transforms":

		return w.starlarkTransforms, nil

	default:
		return nil, nil
	}
}

func (w *Keyframe) String() string       { return "Keyframe(...)" }
func (w *Keyframe) Type() string         { return "Keyframe" }
func (w *Keyframe) Freeze()              {}
func (w *Keyframe) Truth() starlark.Bool { return true }

func (w *Keyframe) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Marquee struct {
	Widget

	render.Marquee

	starlarkChild starlark.Value
}

func newMarquee(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		child            starlark.Value
		width            starlark.Int
		height           starlark.Int
		offset_start     starlark.Int
		offset_end       starlark.Int
		scroll_direction starlark.String
	)

	if err := starlark.UnpackArgs(
		"Marquee",
		args, kwargs,
		"child", &child,
		"width?", &width,
		"height?", &height,
		"offset_start?", &offset_start,
		"offset_end?", &offset_end,
		"scroll_direction?", &scroll_direction,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Marquee: %s", err)
	}

	w := &Marquee{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.Width = int(width.BigInt().Int64())

	w.Height = int(height.BigInt().Int64())

	w.OffsetStart = int(offset_start.BigInt().Int64())

	w.OffsetEnd = int(offset_end.BigInt().Int64())

	w.ScrollDirection = scroll_direction.GoString()

	return w, nil
}

func (w *Marquee) AsRenderWidget() render.Widget {
	return &w.Marquee
}

func (w *Marquee) AttrNames() []string {
	return []string{
		"child", "width", "height", "offset_start", "offset_end", "scroll_direction",
	}
}

func (w *Marquee) Attr(name string) (starlark.Value, error) {
	switch name {

	case "child":

		return w.starlarkChild, nil

	case "width":

		return starlark.MakeInt(w.Width), nil

	case "height":

		return starlark.MakeInt(w.Height), nil

	case "offset_start":

		return starlark.MakeInt(w.OffsetStart), nil

	case "offset_end":

		return starlark.MakeInt(w.OffsetEnd), nil

	case "scroll_direction":

		return starlark.String(w.ScrollDirection), nil

	default:
		return nil, nil
	}
}

func (w *Marquee) String() string       { return "Marquee(...)" }
func (w *Marquee) Type() string         { return "Marquee" }
func (w *Marquee) Freeze()              {}
func (w *Marquee) Truth() starlark.Bool { return true }

func (w *Marquee) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Origin struct {
	animation.Origin

	starlarkX starlark.Value

	starlarkY starlark.Value
}

func newOrigin(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		x starlark.Value
		y starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Origin",
		args, kwargs,
		"x", &x,
		"y", &y,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Origin: %s", err)
	}

	w := &Origin{}

	w.starlarkX = x
	{

		if val, err := NumberOrPercentageFromStarlark(x, -math.MaxFloat64, math.MaxFloat64, map[string]float64{"left": 0.0, "center": 0.5, "right": 1.0}); err == nil {

			w.X = val
		} else {
			return nil, err
		}
	}

	w.starlarkY = y
	{

		if val, err := NumberOrPercentageFromStarlark(y, -math.MaxFloat64, math.MaxFloat64, map[string]float64{"top": 0.0, "center": 0.5, "bottom": 1.0}); err == nil {

			w.Y = val
		} else {
			return nil, err
		}
	}

	return w, nil
}

func (w *Origin) AttrNames() []string {
	return []string{
		"x", "y",
	}
}

func (w *Origin) Attr(name string) (starlark.Value, error) {
	switch name {

	case "x":

		return w.starlarkX, nil

	case "y":

		return w.starlarkY, nil

	default:
		return nil, nil
	}
}

func (w *Origin) String() string       { return "Origin(...)" }
func (w *Origin) Type() string         { return "Origin" }
func (w *Origin) Freeze()              {}
func (w *Origin) Truth() starlark.Bool { return true }

func (w *Origin) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Padding struct {
	Widget

	render.Padding

	starlarkChild starlark.Value

	starlarkPad starlark.Value

	starlarkColor starlark.String
}

func newPadding(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		child    starlark.Value
		pad      starlark.Value
		expanded starlark.Bool
		color    starlark.String
	)

	if err := starlark.UnpackArgs(
		"Padding",
		args, kwargs,
		"child", &child,
		"pad?", &pad,
		"expanded?", &expanded,
		"color?", &color,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Padding: %s", err)
	}

	w := &Padding{}

	if child != nil {
		childWidget, ok := child.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.starlarkPad = pad
	switch padVal := pad.(type) {
	case starlark.Int:
		padInt := int(padVal.BigInt().Int64())
		w.Pad.Left = padInt
		w.Pad.Top = padInt
		w.Pad.Right = padInt
		w.Pad.Bottom = padInt
	case starlark.Tuple:
		padList := []starlark.Value(padVal)
		if len(padList) != 4 {
			return nil, fmt.Errorf(
				"pad tuple must hold 4 elements (left, top, right, bottom), found %d",
				len(padList),
			)
		}
		padListInt := make([]starlark.Int, 4)
		for i := 0; i < 4; i++ {
			pi, ok := padList[i].(starlark.Int)
			if !ok {
				return nil, fmt.Errorf("pad element %d is not int", i)
			}
			padListInt[i] = pi
		}
		w.Pad.Left = int(padListInt[0].BigInt().Int64())
		w.Pad.Top = int(padListInt[1].BigInt().Int64())
		w.Pad.Right = int(padListInt[2].BigInt().Int64())
		w.Pad.Bottom = int(padListInt[3].BigInt().Int64())
	default:
		return nil, fmt.Errorf("pad must be int or 4-tuple of int")
	}

	w.Expanded = bool(expanded)

	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	return w, nil
}

func (w *Padding) AsRenderWidget() render.Widget {
	return &w.Padding
}

func (w *Padding) AttrNames() []string {
	return []string{
		"child", "pad", "expanded", "color",
	}
}

func (w *Padding) Attr(name string) (starlark.Value, error) {
	switch name {

	case "child":

		return w.starlarkChild, nil

	case "pad":

		return w.starlarkPad, nil

	case "expanded":

		return starlark.Bool(w.Expanded), nil

	case "color":

		return w.starlarkColor, nil

	default:
		return nil, nil
	}
}

func (w *Padding) String() string       { return "Padding(...)" }
func (w *Padding) Type() string         { return "Padding" }
func (w *Padding) Freeze()              {}
func (w *Padding) Truth() starlark.Bool { return true }

func (w *Padding) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Rotate struct {
	animation.Rotate

	starlarkAngle starlark.Value
}

func newRotate(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		angle starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Rotate",
		args, kwargs,
		"angle", &angle,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Rotate: %s", err)
	}

	w := &Rotate{}

	w.starlarkAngle = angle
	if val, ok := starlark.AsFloat(w.starlarkAngle); ok {
		w.Angle = val
	} else {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkAngle.String())
	}

	return w, nil
}

func (w *Rotate) AttrNames() []string {
	return []string{
		"angle",
	}
}

func (w *Rotate) Attr(name string) (starlark.Value, error) {
	switch name {

	case "angle":

		return w.starlarkAngle, nil

	default:
		return nil, nil
	}
}

func (w *Rotate) String() string       { return "Rotate(...)" }
func (w *Rotate) Type() string         { return "Rotate" }
func (w *Rotate) Freeze()              {}
func (w *Rotate) Truth() starlark.Bool { return true }

func (w *Rotate) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Row struct {
	Widget

	render.Row

	starlarkChildren *starlark.List
}

func newRow(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		children    *starlark.List
		main_align  starlark.String
		cross_align starlark.String
		expanded    starlark.Bool
	)

	if err := starlark.UnpackArgs(
		"Row",
		args, kwargs,
		"children", &children,
		"main_align?", &main_align,
		"cross_align?", &cross_align,
		"expanded?", &expanded,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Row: %s", err)
	}

	w := &Row{}

	var childrenVal starlark.Value
	childrenIter := children.Iterate()
	defer childrenIter.Done()
	for i := 0; childrenIter.Next(&childrenVal); {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(),
				i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	w.MainAlign = main_align.GoString()

	w.CrossAlign = cross_align.GoString()

	w.Expanded = bool(expanded)

	return w, nil
}

func (w *Row) AsRenderWidget() render.Widget {
	return &w.Row
}

func (w *Row) AttrNames() []string {
	return []string{
		"children", "main_align", "cross_align", "expanded",
	}
}

func (w *Row) Attr(name string) (starlark.Value, error) {
	switch name {

	case "children":

		return w.starlarkChildren, nil

	case "main_align":

		return starlark.String(w.MainAlign), nil

	case "cross_align":

		return starlark.String(w.CrossAlign), nil

	case "expanded":

		return starlark.Bool(w.Expanded), nil

	default:
		return nil, nil
	}
}

func (w *Row) String() string       { return "Row(...)" }
func (w *Row) Type() string         { return "Row" }
func (w *Row) Freeze()              {}
func (w *Row) Truth() starlark.Bool { return true }

func (w *Row) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Scale struct {
	animation.Scale

	starlarkX starlark.Value

	starlarkY starlark.Value
}

func newScale(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		x starlark.Value
		y starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Scale",
		args, kwargs,
		"x", &x,
		"y", &y,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Scale: %s", err)
	}

	w := &Scale{}

	w.starlarkX = x
	if val, ok := starlark.AsFloat(w.starlarkX); ok {
		w.X = val
	} else {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkX.String())
	}

	w.starlarkY = y
	if val, ok := starlark.AsFloat(w.starlarkY); ok {
		w.Y = val
	} else {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkY.String())
	}

	return w, nil
}

func (w *Scale) AttrNames() []string {
	return []string{
		"x", "y",
	}
}

func (w *Scale) Attr(name string) (starlark.Value, error) {
	switch name {

	case "x":

		return w.starlarkX, nil

	case "y":

		return w.starlarkY, nil

	default:
		return nil, nil
	}
}

func (w *Scale) String() string       { return "Scale(...)" }
func (w *Scale) Type() string         { return "Scale" }
func (w *Scale) Freeze()              {}
func (w *Scale) Truth() starlark.Bool { return true }

func (w *Scale) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Stack struct {
	Widget

	render.Stack

	starlarkChildren *starlark.List
}

func newStack(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		children *starlark.List
	)

	if err := starlark.UnpackArgs(
		"Stack",
		args, kwargs,
		"children", &children,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Stack: %s", err)
	}

	w := &Stack{}

	var childrenVal starlark.Value
	childrenIter := children.Iterate()
	defer childrenIter.Done()
	for i := 0; childrenIter.Next(&childrenVal); {
		if _, isNone := childrenVal.(starlark.NoneType); isNone {
			continue
		}

		childrenChild, ok := childrenVal.(Widget)
		if !ok {
			return nil, fmt.Errorf(
				"expected children to be a list of Widget but found: %s (at index %d)",
				childrenVal.Type(),
				i,
			)
		}

		w.Children = append(w.Children, childrenChild.AsRenderWidget())
	}
	w.starlarkChildren = children

	return w, nil
}

func (w *Stack) AsRenderWidget() render.Widget {
	return &w.Stack
}

func (w *Stack) AttrNames() []string {
	return []string{
		"children",
	}
}

func (w *Stack) Attr(name string) (starlark.Value, error) {
	switch name {

	case "children":

		return w.starlarkChildren, nil

	default:
		return nil, nil
	}
}

func (w *Stack) String() string       { return "Stack(...)" }
func (w *Stack) Type() string         { return "Stack" }
func (w *Stack) Freeze()              {}
func (w *Stack) Truth() starlark.Bool { return true }

func (w *Stack) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type Text struct {
	Widget

	render.Text

	starlarkColor starlark.String

	size *starlark.Builtin
}

func newText(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		content starlark.String
		font    starlark.String

		height starlark.Int
		offset starlark.Int
		color  starlark.String
	)

	if err := starlark.UnpackArgs(
		"Text",
		args, kwargs,
		"content", &content,
		"font?", &font,
		"height?", &height,
		"offset?", &offset,
		"color?", &color,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Text: %s", err)
	}

	w := &Text{}

	w.Content = content.GoString()

	w.Font = font.GoString()

	w.Height = int(height.BigInt().Int64())

	w.Offset = int(offset.BigInt().Int64())

	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	w.size = starlark.NewBuiltin("size", textSize)

	if err := w.Init(); err != nil {
		return nil, err
	}

	return w, nil
}

func (w *Text) AsRenderWidget() render.Widget {
	return &w.Text
}

func (w *Text) AttrNames() []string {
	return []string{
		"content", "font", "width", "height", "offset", "color",
	}
}

func (w *Text) Attr(name string) (starlark.Value, error) {
	switch name {

	case "content":

		return starlark.String(w.Content), nil

	case "font":

		return starlark.String(w.Font), nil

	case "width":

		return starlark.MakeInt(w.Width), nil

	case "height":

		return starlark.MakeInt(w.Height), nil

	case "offset":

		return starlark.MakeInt(w.Offset), nil

	case "color":

		return w.starlarkColor, nil

	case "size":
		return w.size.BindReceiver(w), nil

	default:
		return nil, nil
	}
}

func (w *Text) String() string       { return "Text(...)" }
func (w *Text) Type() string         { return "Text" }
func (w *Text) Freeze()              {}
func (w *Text) Truth() starlark.Bool { return true }

func (w *Text) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

func textSize(
	thread *starlark.Thread,
	b *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple) (starlark.Value, error) {

	w := b.Receiver().(*Text)
	width, height := w.Size()

	return starlark.Tuple([]starlark.Value{
		starlark.MakeInt(width),
		starlark.MakeInt(height),
	}), nil
}

type Translate struct {
	animation.Translate

	starlarkX starlark.Value

	starlarkY starlark.Value
}

func newTranslate(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		x starlark.Value
		y starlark.Value
	)

	if err := starlark.UnpackArgs(
		"Translate",
		args, kwargs,
		"x", &x,
		"y", &y,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for Translate: %s", err)
	}

	w := &Translate{}

	w.starlarkX = x
	if val, ok := starlark.AsFloat(w.starlarkX); ok {
		w.X = val
	} else {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkX.String())
	}

	w.starlarkY = y
	if val, ok := starlark.AsFloat(w.starlarkY); ok {
		w.Y = val
	} else {
		return nil, fmt.Errorf("expected number, but got: %s", w.starlarkY.String())
	}

	return w, nil
}

func (w *Translate) AttrNames() []string {
	return []string{
		"x", "y",
	}
}

func (w *Translate) Attr(name string) (starlark.Value, error) {
	switch name {

	case "x":

		return w.starlarkX, nil

	case "y":

		return w.starlarkY, nil

	default:
		return nil, nil
	}
}

func (w *Translate) String() string       { return "Translate(...)" }
func (w *Translate) Type() string         { return "Translate" }
func (w *Translate) Freeze()              {}
func (w *Translate) Truth() starlark.Bool { return true }

func (w *Translate) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}

type WrappedText struct {
	Widget

	render.WrappedText

	starlarkColor starlark.String
}

func newWrappedText(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		content     starlark.String
		font        starlark.String
		height      starlark.Int
		width       starlark.Int
		linespacing starlark.Int
		color       starlark.String
	)

	if err := starlark.UnpackArgs(
		"WrappedText",
		args, kwargs,
		"content", &content,
		"font?", &font,
		"height?", &height,
		"width?", &width,
		"linespacing?", &linespacing,
		"color?", &color,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for WrappedText: %s", err)
	}

	w := &WrappedText{}

	w.Content = content.GoString()

	w.Font = font.GoString()

	w.Height = int(height.BigInt().Int64())

	w.Width = int(width.BigInt().Int64())

	w.LineSpacing = int(linespacing.BigInt().Int64())

	if color.Len() > 0 {
		c, err := render.ParseColor(color.GoString())
		if err != nil {
			return nil, fmt.Errorf("color is not a valid hex string: %s", color.String())
		}
		w.Color = c
	}

	return w, nil
}

func (w *WrappedText) AsRenderWidget() render.Widget {
	return &w.WrappedText
}

func (w *WrappedText) AttrNames() []string {
	return []string{
		"content", "font", "height", "width", "linespacing", "color",
	}
}

func (w *WrappedText) Attr(name string) (starlark.Value, error) {
	switch name {

	case "content":

		return starlark.String(w.Content), nil

	case "font":

		return starlark.String(w.Font), nil

	case "height":

		return starlark.MakeInt(w.Height), nil

	case "width":

		return starlark.MakeInt(w.Width), nil

	case "linespacing":

		return starlark.MakeInt(w.LineSpacing), nil

	case "color":

		return w.starlarkColor, nil

	default:
		return nil, nil
	}
}

func (w *WrappedText) String() string       { return "WrappedText(...)" }
func (w *WrappedText) Type() string         { return "WrappedText" }
func (w *WrappedText) Freeze()              {}
func (w *WrappedText) Truth() starlark.Bool { return true }

func (w *WrappedText) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}
